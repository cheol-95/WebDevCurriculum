# Quest 06. 인터넷의 이해

## 인터넷은 어떻게 동작하나요? Internet Protocol Suite의 레이어 모델에 입각하여 설명해 보세요.

- HTTP(5계층) -> TCP(4계층) -> IP/ 라우터(3계층) -> 이더넷/ 스위치(2계층) -> 케이블(1계층)

### HTTP? (Hyper Tex Transfer Protocol)

- W3 상에서 정보를 주고 받을 수 있는 프로토콜로, 주로 TCP를 사용하고 HTTP/3 부터는 UDP를 사용하며, 80번 포트를 사용한다.
- 클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜이다.
- 메시지 포맷: 평문(ASCII) 메시지로 이루어진다.

  - 요청

    - 요청 내용 (url로 자원 요청)
    - 요청 헤더필드: 인증, 캐싱, 연결관리, 컨텐츠 협상, CORS 등
    - 빈줄

  - 응답
    - 상태표시 행: status code, reason message (예. HTTP/1.1 200 OK.)
    - 응답 헤더필드: 컨텐츠 타입 등
    - 빈줄
    - 기타 메시지

[HTTP 헤더](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers)

### TCP? (Transmission Control Protocol)

- 전송 제어 프로토콜로, 근거리 통신망이나 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟을 안정적으로, 순서대로, 에러없이 교환할 수 있게한다.
- TPC는 데이터 스트림으로부터 데이터를 받아 청크 단위로 분할한 뒤 TCP 헤더를 붙여 TCP 세그먼트를 생성한다. 이는 IP 데이터그램에 캡슐화되어 상대방과 주고 받게 된다.
- 신뢰성 있는 연결이 생성되어야 하며, 그 후 자료를 전송하고, 마지막으로 연결을 종료하면서 할당된 자원을 반납한다.

- 3-way-handshake: 연결을 생성하기 위해 사용

  1. SYN: 클라이언트가 서버에서 SYN 메시지를 보낸다. 이 메시지에 포함된 시퀀스 번호는 임의의 값 A
  1. SYN-ACK: 서버가 클라이언트에게 SYN-ACK 메시지로 응답한다. 이 메시지에 포함된 시퀀스 번호는 서버가 임의로 설정한 값 B, 응답 번호는 (A+1)
  1. ACK: 클라이언트가 서버에게 ACK 메시지를 보낸다. 이 메시지에 포함된 응답 번호는 (B+1)

- 4-way-handshake: 연결을 종료하기 위해 사용

  1. FIN: 클라이언트가 서버에게 연결 종료를 알리는 FIN 메시지를 보낸다.
  2. ACK: 서버는 확인 메시지로 ACK를 보낸다. 데이터를 모두 보낼때 까지 TIME_OUT이 된다.
  3. FIN:데이터를 모두 보내고 통신이 끝났으면 클라이언트에게 FIN 메시지를 보낸다.
  4. ACK: 클라이언트가 서버에게 ACK 메시지를 보낸다.
  5. 이후 클라이언트는 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기자리는 과정을 거친다.(TIME_WAIT)

<br>

### IP? (Internet Protocol)

- 패킷 교환 네트워크에서 데이터를 주고받는 데 사용하는 정보 위주의 프로토콜이며, OIS 네트워크 계층에서 호스트의 주소지정과 패킷 분할 및 조립 기능을 담당한다.
- IP의 정보는 패킷 혹은 데이터그램이라고 하는 덩어리고 나뉘어 전송된다. IP에서는 이전에 통신한 적 없는 호스트에 패킷을 보낼 때 경로 설정이 필요없다.
- IP는 비신뢰성과 비연결성이 특징이다.

  - 비신뢰성은 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다는 뜻이다.
  - 예를 들어 전송 과정에서 패킷이 손상될 수도 있고, 같은 호스트에서 전송한 패킷의 순서가 뒤죽박죽이 될 수도 있고, 같은 패캣이 두 번 전송될 수도 있으며, 아예 패킷이 사라질 수도 있다.

- 현재 인터넷에서 사용하는 표준 프로토콜은 IPv4 이지만 주소공간 고갈 문제를 겪고 있어 조만간 IPv6 가 대중화될 것으로 보인다.

- IPv4?

  - ps://ip.pe.kr 인터넷 프로토콜의 4번째 판이며, 전 세계적으로 사용된 첫 번째 인터넷 프로토콜이다.
  - 주소체계는 총 12자리, 네 부분으로 나뉘며, 각 부분은 0~255까지 3 자리의 수로 표현된다.
  - 32비트로 구성되어 있으며 2011년 2월 4일부로 모든 IPv4 주소가 소진되어 IPv4의 할당이 중지되었다.
  - 특수 용도 주소?

    | 주소 대역      | 용도                          |
    | -------------- | ----------------------------- |
    | 0.0.0.0/8      | 자체 네트워크                 |
    | 10.0.0.0/8     | 사설 네트워크                 |
    | 127.0.0.0/8    | 루프백(loopback) 즉, 자기자신 |
    | 169.254.0.0/16 | 링크 로컬(link local)         |
    | 172.16.0.0/12  | 사설 네트워크                 |
    | 192.0.2.0/24   | 예제 등 문서에서 사용         |
    | 192.88.99.0/24 | 6to4 릴레이 애니캐스트        |
    | 192.168.0.0/16 | 사설 네트워크                 |
    | 198.18.0.0/15  | 네트워크 장비 벤치마킹 테스트 |
    | 224.0.0.0/4    | 멀티캐스트                    |
    | 240.0.0.0/4    | 미래 사용 용도로 예약         |

- IPv6?
  - IPv4 의 주소가 거의 소진되고 있다는 한계점으로 인해 제안되었으며 RFC를 통해 국제 표준이 되었고, 실제로 휴대폰 및 컴퓨터에 할당되어 적용되고 있다.
  - IP주소의 길이가 128비트로 늘어났고, 새로운 기능을 제공하는 동시에 기존 IPv4 와의 호환성을 최대로 하는 방향으로 설계되었다.
  - 호스트 주소 자동 설정: IPv6 호스트는 IPv6 네트워크에 접속하는 순간 자동적으로 네트워크 주소를 부여받는다. 이는 네트워크 관리자로부터 IP 주소를 부여받아 수동으로 설정해야 했던 IPv4 에 비해 중요한 이점이다.

<br>

### ARP? (Address Resolution Protocol)

- 주소 결정 프로토콜로, 네트워크 상에서 IP 주소를 `물리적 네트워크 주소`로 바인딩하기 위해 사용된다.
- 여기서 말하는 물리적 네트워크 주소는 이더넷 또는 토큰링의 48비트 네트워크 카드 주소를 뜻한다.
- 토큰링? (Token ring)

  - OSI 모델의 데이터 링크 계층에서 쓰이는 근거리 통신망 프로토콜로, 80년도 개발 당시에는 매우 성공적이었으나 이더넷의 등장으로 사용되지 않게 되었다.
  - 여러 컴퓨터들이 하나의 링에 이어져 형성되며, 보통 3바이트로 이루어진 하나의 제어토큰이 생성되어 한 방향으로 링을 순환하며 컴퓨터들의 네트워크 접속을 제어한다.
  - 같은 네트워크 내의 컴퓨터에 전달하고자 하는 컴퓨터는 이 토큰을 획득하여야만 전송을 할 수 있다.

### 이더넷? (Ethernet)

- LAN, MAN 및 WAN에서 가장 많이 활용되는 기술 규격이다.
- OSI 모덜의 물리 계층에서 신호와 배선, 데이터 링크 계층에서 MAC패킷과 프로토콜의 형식을 정의한다.
- 네트워크에 연결된 각 기기들이 48비트 길이의 고유의 MAC주소를 가지고 있으며, 이 주소를 이용해 상호간에 데이터를 주고 받을 수 있도록 만들어졌다.
- CSMA/CD 방식을 사용해 이더넷에 연결된 여러 컴퓨터들이 하나의 전송 매체를 공유할 수 있도록 한다.
- 동작절차
  1. 네트워크를 사용하려는 컴퓨터는 먼저 현재 네트워크 위에 흐르고 있는 데이터가 있는지를 감지한다.
  2. 만약 현재 다른 데이터가 전송 중이면 사용할 수 있을 때까지 기다리고 아니면 전송을 시작한다.
  3. 여러 군데에서 동시에 전송을 시작해 충돌이 발생하면 최소 패킷 시간 동안 전송을 계속해, 다른 컴퓨터가 충돌을 탐지할 수 있또록 한다.
  4. 그 뒤, 임의 시간 동안 기다린 뒤에 다시 신호(반송파)를 감지하고, 네트워크 사용자가 없으면 전송을 다시 시작한다.
  5. 전송을 마치면, 상위 계층에 전송이 끝났음을 알리고 끝마친다.
  6. 여러 번 다시 시도했음에도 전송이 실패하면 이를 상위 계층에 알리고 끝마친다.

| 이더넷 허브           | 이더넷 스위치            |
| --------------------- | ------------------------ |
| 각 컴퓨터의 주소 모름 | 각 컴퓨터의 MAC주소 저장 |
| Broadcasting          | 목적지로 전달            |
| half duplex           | full duplex              |

<br><br>

### 인터넷 프로토콜 스택 구조

| 계층                     | 프로토콜      |
| ------------------------ | ------------- |
| 응용계층                 | HTTP, DNS     |
| 전송계층                 | TCP, UDP      |
| 인터넷계층               | IP            |
| ARP                      | ARP           |
| 네트워크 인터페이스 계층 | 이더넷, Wi-Fi |

<br><br>

### TCP/IP 4계증

- 1계층 네트워크 인터페이스 층: 이더넷, 무선LAN, PPP => 물리적 접속

  - 네트워크 안에서 데이터를 전송하는 역할
  - 하나의 네트워크는 라우터와 레이어3 스위치로 구획되는 범위
  - 인터페이스(포트): 기기 간의 연결을 위해 필요한 것
  - 디지털 데이터와 물리적 신호의 경계

- 2계층 인터넷 층: IP, ICMP, ARP => 논리적 접속

  - 네트워크 사이에서 데이터를 전송하는 역할
  - 엔드 투 엔트 통신 (최종 출발지와 목적지 사이의 데이터 전송으로, 라우팅의 핵심)

    - IP: 엔드 투 엔드 통신에 이용하는 프로토콜

      - IP 헤더를 추가해 IP 패킷으로 만든다. IP 헤더에는 목적지와 출발지의 IP주소가 지정되어야 한다.
      - IP로 데이터를 다른 호스트에 전송하지만, 제대로 도작했는지 확인할 방법은 없다.

    - ICMP: 엔드 투 엔드 통신이 정상적으로 이루어 졌는지 확인하는 프로토콜

      - 에러 리포트: IP 패킷을 폐기할 경우, 에러 리포트 전송
      - 진단 기능: 엔드 투 엔드 통신 가능 여부를 확인하는 진단. PING 컴맨드를 보내 지정한 IP 주소와 통신할 수 있는지 확인

    - ARP: IP주소와 인터페이스를 식별하기 위한 MAC 주소를 대응시키는 역할 (주소 해석)
      - ARP에 의해 자동으로 주소 해석하고, 목적지 IP 주소에 대응하는 목적지 MAC 주소를 구할 수 있다.
      - 같은 네트워크 내의 IP 주소만 주소 해석이 가능하다.

  - 서브넷 마스크

    - 네트워크부와 호스트부의 구분은 가변적이며, 32비트 IP주소 중 어디까지가 네트워크부인지 명시한 것이 서브넷 마스크이다.
    - 1: 네트워크 / 0: 호스트부를 나타낸다.

- 3계층 트랜스포트 층: TCP/UDP

  - 데이터를 적절한 어플리케이션에 할당하는 역할
  - TCP: 신뢰성 확보
    - TCP 세그먼트 = TCP 헤더 + HTTP 헤더 + 어플리케이션 헤더
    - 시퀀스 번호: TCP로 데이터를 전송하는 순서
    - ACK 번호: 데이터를 바르게 수신했음을 확인하기 위해 이용
  - 포트 번호
    - 호스트에서 동작하는 어플리케이션에 데이터를 배분하기 위한 어플리케이션 식별 번호로, TCP/UDP 헤더에 지정.
    1. 웰노운 포트 번호: 서버 어플리케이션용으로 예약된 포트 번호
    2. 등록된 포트: 자주 이용되는 서버 어플리케이션 포트 번호
    3. 동적/ 사설 포트: 클라이언트 어플리케이션용 포트 번호

- 4계층 어플리케이션 층: HTTP, SMTP, POP3 등
  - 어플리케이션에서 기능을 실행하기 위한 데이터 형식과 처리 절차를 결정하는 역할. 단순한 0과 1이 아닌, 인간이 인식할 수 있는 데이터로 표현한다.
  - `웹 서버 어플리케이션 <====> 프록시 서버 어플리케이션 <====> 클라이언트`

<br><br>

## 근거리에서 서로 떨어진 두 전자기기가 유선/무선으로 서로 통신하는 프로토콜은 어떻게 동작할까요?

- PPP(Point to Point Protocol)는 두 통신 노드 간의 직접적인 연결을 위해 일반적으로 사용되는 데이터 링크 프로토콜로 인증, 암호화를 통한 전송 및 데이터 압축 기능을 제공한다.
- PPP는 IP 프로토콜을 시리얼 통신하기 위한 표준 규약이므로, 데이터 링크 계층에 존재한다.
- 종단간의 링크에 Connection을 개설, 유지, 관리하는 역할을 해주며 IP를 캡슐화하는 용도로 많이 사용된다.
- 내부적으로 NCP를 사용해 프로토콜을 제어하는데, 가장 대표적으로 IP를 제어하는 IPCP(IP Control Protocol)이 있다.
- IPCP는 유동 IP를 할당 받고, DNS와 Default Gateway 등 IP 주소를 얻는 역할을 한다.

<br><br>

## 근거리에 있는 여러 대의 전자기기가 서로 통신하는 프로토콜은 어떻게 동작할까요?

- 근거리 통신망, 로컬 영역 네트워크(Local Area Network, LAN)는 네트워크 매체를 이용하여 집, 사무실, 학교 등의 건물과 같은 가까운 지역을 한데 묶는 컴퓨터 네트워크이다.
- 주로 이더넷과 와이파이를 사용하며, 중계기(스위치/ 라우터)가 각 전자기기의 MAC 주소를 저장한다.
- A 전자기기에서 B 전자기기에 메시지를 전송하고 싶으면, 스위치로 메시지를 전송하고, 스위치에서 B 전자기기로 메시지를 전송한다.
- 이더넷 작동 절차

  1. 네트워크를 사용하려는 컴퓨터는 먼저 현재 네트워크 위에 흐르고 있는 데이터가 있는지를 감지한다.
  2. 만약 현재 다른 데이터가 전송 중이면 사용할 수 있을 때까지 기다리고 아니면 전송을 시작한다.
  3. 여러 군데에서 동시에 전송을 시작해 충돌이 발생하면 최소 패킷 시간 동안 전송을 계속해, 다른 컴퓨터가 충돌을 탐지할 수 있또록 한다.
  4. 그 뒤, 임의 시간 동안 기다린 뒤에 다시 신호(반송파)를 감지하고, 네트워크 사용자가 없으면 전송을 다시 시작한다.
  5. 전송을 마치면, 상위 계층에 전송이 끝났음을 알리고 끝마친다.
  6. 여러 번 다시 시도했음에도 전송이 실패하면 이를 상위 계층에 알리고 끝마친다.

- 침입자가 물리적인 연결을 할 필요가 없기 때문에 무선 연결이 덜 안전하다.
- 초기 암호화 WEP는 쉽게 뚫릴 수 있었으며, 이후 너 높은 품질의 프로토콜 WPA, WPA2들이 추가되었다.

<br><br>

## 아주 멀리 떨어져 있는 두 전자기기가 유선/무선으로 서로 통신하는 프로토콜을 어떻게 동작할까요?

- PPPoE를 통해 다이얼 업 접속으로 인터넷에 접속한다. 이후 다른 프로토콜과 마찬가지로 TCP/ IP를 이용해 통신한다.

<br>

## 두 전자기기가 신뢰성을 가지고 통신할 수 있도록 하기 위한 프로토콜을 어떻게 동작할까요?

- TCP는 전송 제어 프로토콜로, 근거리 통신망이나 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟을 안정적으로, 순서대로, 에러없이 교환할 수 있게한다.
- TPC는 데이터 스트림으로부터 데이터를 받아 청크 단위로 분할한 뒤 TCP 헤더를 붙여 TCP 세그먼트를 생성한다. 이는 IP 데이터그램에 캡슐화되어 상대방과 주고 받게 된다.
- 신뢰성 있는 연결이 생성되어야 하며, 그 후 자료를 전송하고, 마지막으로 연결을 종료하면서 할당된 자원을 반납한다.

- 3-way-handshake: 연결을 생성하기 위해 사용

  1. SYN: 클라이언트가 서버에서 SYN 메시지를 보낸다. 이 메시지에 포함된 시퀀스 번호는 임의의 값 A
  1. SYN-ACK: 서버가 클라이언트에게 SYN-ACK 메시지로 응답한다. 이 메시지에 포함된 시퀀스 번호는 서버가 임의로 설정한 값 B, 응답 번호는 (A+1)
  1. ACK: 클라이언트가 서버에게 ACK 메시지를 보낸다. 이 메시지에 포함된 응답 번호는 (B+1)

- 4-way-handshake: 연결을 종료하기 위해 사용

  1. FIN: 클라이언트가 서버에게 연결 종료를 알리는 FIN 메시지를 보낸다.
  2. ACK: 서버는 확인 메시지로 ACK를 보낸다. 데이터를 모두 보낼때 까지 TIME_OUT이 된다.
  3. FIN:데이터를 모두 보내고 통신이 끝났으면 클라이언트에게 FIN 메시지를 보낸다.
  4. ACK: 클라이언트가 서버에게 ACK 메시지를 보낸다.
  5. 이후 클라이언트는 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기자리는 과정을 거친다.(TIME_WAIT)

<br>

## HTTP는 어떻게 동작할까요?

- TCP/IP 위에서 동작하는 프로토콜로, 소통은 평문 메시지(ASCII)로 이루어진다.
- 기본적인 구조는 클라이언트의 요청과 서버의 응답이며, `stateless` 하다.
- 요청
  - HTTP Method, url, version을 명시해 요청하고 헤더에 요청에 관련한 메타데이터를 첨부한다.
- 응답
  - Status Code, Reason Message, version을 명시하고 응답 헤더, 응답 메시지로 이루어져 있다.

<br><br>

## 우리가 브라우저의 주소 창에 www.knowre.com 을 쳤을 때, 어떤 과정을 통해 서버의 IP 주소를 알게 될까요?

- DNS을 통해 `www.knowre.com` 이라는 도메인 이름을 IP주소인 `190.60.103.225:443` 으로 변환한다.

- 로컬 캐싱 조회

  - 브라우저 DNS 캐싱을 확인한다.
  - OS 수준 DNS 캐싱을 확인한다.
    1. `스텁 확인자` 또는 `DNS 클라이언트`는 자체 케시를 검사하여 레코드가 았는지 확인한다.
    2. 존재하지 않는다면 로컬 네트워크 외부의 DNS 쿼리를 ISP 내부의 DNS 확인자로 보낸다.

- DNS 조회 절차
  1. 사용자가 웹 브라우저에 `www.knowre.com`을 입력하면, 쿼리가 인터넷으로 이동하고 DNS 재귀 확인자가 이를 수신한다.
  2. 이어서 확인자가 DNS 루트 이름 서버를(.)를 쿼리한다.
  3. 루트 서버가, 도메인에 대한 정보를 저장하는 최상위 도메인(TLD) DNS 서버(`.com`)의 주소로 확인자에 응답한다.
  4. 확인자가 .com TLD에 요청한다.
  5. TLD 서버가 도메인 이름 서버(`knowre.com`)의 IP 주소로 응답한다.
  6. 재귀 확인자가 도메인의 이름 서버로 쿼리를 보낸다.
  7. 최종 IP 주소가 이름 서버에서 확인자에게 반환된다.
  8. DNS 확인자가 처음 요청한 도메인의 IP 주소로 웹 브라우저에 응답한다.

### DNS? (Domain Name System)

- 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행한다.
- TCP/IP의 응용에서, 컴퓨터의 도메인 이름을 IP 주소로 변환하고 라우팅 정보를 제공하는 분산형 데이터베이스 시스템이다.
- 도메인 네임 계층을 관리하며 해당 네임 계층과 주소 공간 간의 변환 서비스를 제공한다.
- DNS 네임 서버는 도메인을 위한 DNS 레코드를 저장하는 서버이다.

<br><br><br>

# Quest

## tracert(or traceroute) 명령을 통해 www.google.com 까지 가는 경로를 찾아보세요.

### 어떤 IP주소들이 있나요?

```
~ traceroute www.google.com
traceroute to www.google.com (172.217.174.100), 64 hops max, 52 byte packets
 1  10.180.190.1 (10.180.190.1)  2.109 ms  1.789 ms  1.810 ms
 2  * * *
 3  121.138.235.85 (121.138.235.85)  10.594 ms  6.986 ms  3.608 ms
 4  112.189.35.153 (112.189.35.153)  2.603 ms  2.685 ms  2.415 ms
 5  112.189.14.133 (112.189.14.133)  3.179 ms
    112.189.29.81 (112.189.29.81)  2.771 ms
    112.189.13.133 (112.189.13.133)  3.321 ms
 6  * * *
 7  112.174.47.230 (112.174.47.230)  4.402 ms
    112.174.47.234 (112.174.47.234)  4.206 ms
    112.174.7.50 (112.174.7.50)  3.353 ms
 8  72.14.194.194 (72.14.194.194)  36.959 ms  38.109 ms  31.388 ms
 9  108.170.242.129 (108.170.242.129)  34.127 ms
    108.170.242.97 (108.170.242.97)  35.899 ms  33.121 ms
10  209.85.253.59 (209.85.253.59)  38.024 ms
    209.85.253.57 (209.85.253.57)  37.031 ms  34.400 ms
11  nrt12s28-in-f4.1e100.net (172.217.174.100)  32.127 ms  31.489 ms  32.498 ms
```

<br>

### 그 IP 주소들은 어디에 위치해 있나요?

```
~ traceroute www.google.com
traceroute to www.google.com (172.217.174.100), 64 hops max, 52 byte packets
 1  10.180.190.1 (로컬)
 2  * * *
 3  121.138.235.85 (경기도 분당)
 4  112.189.35.153
 5  112.189.14.133
    112.189.29.81
    112.189.13.133
 6  * * *
 7  112.174.47.230
    112.174.47.234
    112.174.7.50 (경기도 분당)
 8  72.14.194.194 (Mountain View - 미국)
 9  108.170.242.129
    108.170.242.97
10  209.85.253.59
    209.85.253.57
11  nrt12s28-in-f4.1e100.net (172.217.174.100) (Mountain View - 미국)
```

<br><br>

## Wireshark를 통해 www.google.com 으로 요청을 날렸을 때 어떤 TCP 패킷이 오가는지 확인해 보세요.

### TCP 패킷을 주고받는 과정은 어떻게 되나요?

1. 3 Way Handshake
   | Source | Destination | protocol | info |
   | ------ | ----------- | -------- | ---- |
   | 10.180.191.51 | 172.217.175.110 | TCP | 56213 -> 80 [SYN] |
   | 172.217.175.110 | 10.180.191.51 | TCP | 80 -> 56213 [SYN, ACK] |
   | 10.180.191.51 | 172.217.175.110 | TCP | 56213 -> 80 [ACK] |

<br>

2. HTTP 통신
   | Source | Destination | protocol | info |
   | ------ | ----------- | -------- | ---- |
   | 10.180.191.51 | 172.217.175.110 | HTTP | GET / HTTP/1.1 |
   | 172.217.175.110 | 10.180.191.51 | HTTP | HTTP/1.1 301 Moved Permanetly (text/html) |

<br>

3. 4 Way Handshake
   | Source | Destination | protocol | info |
   | ------ | ----------- | -------- | ---- |
   | 172.217.175.110 | 10.180.191.51 | TCP | 80 -> 56213 [FIN ACK] |
   | 10.180.191.51 | 172.217.175.110 | TCP | 56213 -> 80 [ACK] |
   | 10.180.191.51 | 172.217.175.110 | TCP | 56213 -> 80 [FIN ACK] |
   | 172.217.175.110 | 10.180.191.51 | TCP | 80 -> 56213 [ACK] |

<br>

- 질문: 아래와 같은 결과가 나올때도 있던데 이건 어떤 경우인가요?
  | Source | Destination | protocol | info |
  | --------------- | --------------- | -------- | --------------------- |
  | 172.217.175.110 | 10.180.191.51 | TCP | 80 -> 56213 [FIN ACK] |
  | 10.180.191.51 | 172.217.175.110 | TCP | 56213 -> 80 [FIN ACK] |

<br>

### 각각의 패킷에 어떤 정보들이 담겨 있나요?

- Ethernet
  - Source, Destination의 MAC Address
  - IP 버전(IPv4)
- IP
  - 데이터그램이 속한 프로토콜 버전
  - 헤더와 데이터의 길이를 합한 Total Length
  - Protocol
  - Source, Destination의 IP Address
- TCP

  - Source, Destination의 Port
  - Sequence Number: 송신된 데이터의 순서번호, TCP 세그먼트에 대한 식별자
  - Acknowledgement Number: 수신된 바이트 수 + ACK, 다음 번에 기대되는 순차번호를 표시
  - HeaderLength: 헤더 크기
  - Window: TCP 수신 버퍼의 바이트 크기 -> 수신자가 사용 가능한 버퍼 공간
  - CheckSum: TCP PDU 전체와 IP 계층의 헤더 중 후반부 12바이트(IP주소)에 대한 오류 검출 코드
  - Flag

    - SYN: 연결 요청 시 사용되며 Seq Num 초기값을 알린다.
    - ACK: 확인 응답 패킷
    - FIN: 트랜젝션 종료

  - Seq, Ack Number 계산법
    | Client | Direction | Server|
    |:-:|:-:|:-:|
    |seq:1, ack:1 , len:1325| --> | -|
    |-| <-- | seq:1, ack:1326 , len:410|
    |seq:1326, ack:411 , len:0| --> | -|

<br>
<br>

## telnet 명령을 통해 http://www.google.com/ URL에 HTTP 요청을 날려 보세요.

### 어떤 헤더들이 있나요?

### 그 헤더들은 어떤 역할을 하나요?

- Date: HTTP 메시지 생성시간
- Cache-Control: 요청과 응답 모두에서의 캐싱 메커니즘을 명시
- Content-type: 미디어 타입 정보
- Expires: 응답이 만료되었다고 판단하는 시간
- Server: 서버 프로그램 정보
- X-XSS-Protection: XSS 공격을 감지 할 때 페이지 로드를 중지
- X-Frame-Option: 해당 페이지를 `<frame>` 또는 `<iframe>`, `<object>`에서 렌더링 할 수 있는지 여부를 나타냄
- Set-Cookie: 서버에서 클라이언트에게 쿠기 전달
- Access-Ranges: 부분 요청의 지원을 알리기 위해 서버에 의해 사용되는 표식. 이 헤더가 존재하면 브라우저는 처음부터 다시 다운로드를 시작하지 않고, 중단된 다운로드는 재개한다.
- Vary: 캐시 된 응답을 이후 요청들에서 대신 사용할 수 있는지 결정함
- Transfer-Encoding: 사용자에게 entity를 안전하게 전송하기 위해 사용하는 인코딩 방식을 지정

<br>
<br>
<br>

# Advanced

## HTTP의 최신 버전인 HTTP/3는 어떤 식으로 구성되어 있을까요?

- `사용자 공간 혼잡 제어`를 전송 계층 통신 프로토콜의 하나인 `QUIC`를 사용한다.
- 구글이 개발한 QUIC는 `UDP`를 경유하여 사용되는 프로토콜로, HTTP/2 `Head Of Line Blocking`을 해결하기 위해 사용되었다.
  - HOLB?
    - TCP에서 어떤 요청에 병목에 생겨서 전체적인 레이턴시가 늘어나는것
    - 대표적으로 패킷이 중간에 유실되거나 수신 측의 패킷 파싱 속도가 느릴 경우 발생
- 스트림 연결과 암호화 스펙 등을 포함한 모든 핸드쉐이크가단일 요청/ 응답으로 끝난다.
- 패킷이 개별적으로 암호화 되며, 다른 데이터 부분의 패킷을 기다릴 필요가 없다.
- 통신이 멀티플렉싱이 되며 이를 통해 HOLB를 극복할 수 있다.
- Source Address와 무관하게 서버에 대한 연결을 고유하게 식별하는 연결 식별자가 포함되어 있어, IP주소가 변경되더라도 커넥션을 유지할 수 있다.

<br>
<br>

## TCP/IP 외에 전세계적인 네트워크를 구성하기 위한 다른 방식도 제안된 바 있을까요?

- 잘 모르겠습니다!

# 질문

- 361 Line
