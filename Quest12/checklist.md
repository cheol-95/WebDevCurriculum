# Quest12. 보안의 기초

## 입력 데이터의 Validation을 웹 프론트엔드에서 했더라도 서버에서 또 해야 할까요? 그 이유는 무엇일까요?

- 들어오는 데이터의 무결성을 보장하기 위해, 공격을 방지하기 위해서 서버에서 Validation을 확인해야 한다.
- 스크립트나 쿼리 삽입 등으로 인해 공격자가 리소스 또는 어플리케이션 자체를 제어하는 등 의도치 않은 동작을 할 수 있다.

<br><br>

### 서버로부터 받은 HTML 내용을 그대로 검증 없이 프론트엔드에 innerHTML 등을 통해 적용하면 어떤 문제점이 있을까요?

- 공격자가 넣은 스크립트가 다른 사용자에게 그대로 렌더링되기 때문에 보안에 취약해진다.

<br><br>

### XSS(Cross-site scripting)이란 어떤 공격기법일까요?

- 관리자가 아닌 권한이 없는 사용자가 웹 사이트에 스크립트를 삽입하는 공격 기법으로 지속형, 반사형, DOM 기반형 등이 있다.
  - 지속형
    - 해커가 XSS 취약점이 있는 곳(게시판)을 파악해 악성 스크립트를 삽입한다. 이후 `DB`에 저장되고, 해당 게시글을 열람한 사용자들은 악성 스크립트가 작동되면서 쿠키를 탈취당하거나 다른 사이트로 리 다이렉션 되는 공격을 받게 된다.
  - 반사형
    - Reflected XSS 공격은 사용자에게 입력 받은 값을 서버에서 되돌려 주는 곳에서 발생한다.
  - DOM형
    - 악의적인 스크립트가 포함 된 URL을 사용자가 요청하게 되어 브라우저를 해석하는 단계에 발생하는 공격이다.
- 입출력 값 검증, XSS 방어 라이브러리, 웹 방화벽 등을 사용해 방어할 수 있다.

<br><br>

### CSRF(Cross-site request forgery)이란 어떤 공격기법일까요?

- 공격자가 HTTP 요청을 사용하여 다른 사이트에서 인증된 사용자 정보에 액세스하는 것으로, 공격자는 위조된 요청에 대한 응답을 볼 수 없기 때문에 데이터 도난이 아닌 상태 변경 요청을 대상으로 한다.
- 로그인 자격 증명을 변경하거나 물건 구매 등 사용자가 의도치 않은 행위를 할 수 있다.
- `CSRF 토큰`을 사용하여 공격을 방지할 수 있다.

<br><br>

### SQL Injection이란 어떤 공격기법일까요?

- 코드 주입을 사용하여 데이터베이스를 공격하는 기술로, 해커는 클라이언트에서 애플리케이션으로 입력을 통해 악성 쿼리를 삽입한다.
- 변수 바인딩을 사용하여 공격을 방어할 수 있다.

  ```
  txtUserId = getRequestString("UserId");
  txtSQL = "SELECT * FROM Users WHERE UserId = " + txtUserId;

  위와 같은 상황에서 txtUserId 에 입력된 데이터가 "105 OR 1=1" 라면,

  SELECT * FROM Users WHERE UserId = 105 OR 1=1;

  로 쿼리가 실행되어 모든 유저 정보가 유출된다.
  ```

<br><br>

---

<br><br>

## 대부분의 최신 브라우저에서는 HTTP 대신 HTTPS가 권장됩니다. 이유가 무엇일까요?

- 평문으로 통신하는 HTTP 통신에 암호화 과정을 더해 도청 및 변조를 방지하기 위해 권장된다.

### HTTPS와 TLS는 어떤 식으로 동작하나요? HTTPS는 어떤 역사를 가지고 있나요?

- HTTPS는 기본적으로 공개키/ 개인키 기반으로 데이터를 암호화하고 있다.
- 동작

  1. 서버는 CA에 공개키와 서버 정보를 전송하여 인증서를 요청한다.
  2. CA는 인증서를 생성하고 CA-개인키로 암호화하여 서버에게 응답한다.
  3. 클라이언트는 `랜덤 데이터 + 암호화 방식 후보`와 함께 서버에게 요청을 보낸다. (Client Hello)
  4. 서버는 `랜덤 데이터 + 선택한 암호화 방식`과 함께 `인증서`를 제공한다. (Server Hello)
  5. 브라우저는 저장되어있는 CA-공개키를 사용해 인증서를 복호화하여 서버-공개키를 얻는다.
  6. 자신의 `랜덤 데이터와 서버의 랜덤 데이터를 조합해 대칭키를 생성`하고, 이를 서버의 공개키로 암호화하여 요청한다.
  7. 서버는 자신의 개인키로 해당 요청을 복호화해 대칭키를 얻는다.
  8. 이후 대칭키를 기반으로 암호화를 해 통신한다.

- 역사

  - 1986년, SDNS(Secure Data Network System)이라는 프로젝트로 시작되었다.
  - 원래 SP4 프로토콜로 알려졌으나 TLS로 이름이 바뀌었고 1995년에 SSL 2.0이 국제 표준이 되었다.
  - 현재 모든 SSL은 및 TLS v1.1 이하는 더 이상 사용되지 않는다.

- TLS 1.1 (사용x)

  - 2006년, CRC(암호 블록 체임)공격에 대한 보호 기능 추가
  - 매개 변수의 IANA 등록 지원

- TLS 1.2

  - 2008년, DM5-SHA-1 조합이 SHA-256으로 대체되었고, 해시 크기는 96비트 이상이어야 한다.
  - 디지털 서명된 요소의 MD5–SHA-1 조합은 핸드셰이크 중에 협상된 단일 해시로 대체되었으며 기본값은 SHA-1이다.
  - 클라이언트와 서버가 허용하는 해시 및 서명 알고리즘을 지정하는 기능이 향상되었다.

- TLS 1.3
  - 20018년, DM5 및 SHA-224 함호화 해시 함수에 대한 지원이 제거되었다.

<br><br>

### HTTPS의 서비스 과정에서 인증서는 어떤 역할을 할까요? 인증서는 어떤 체계로 되어 있을까요?

- 역할

  - 서버에서 전달받은 인증서가 신뢰할 만한 인증기관으로부터 발급된 인증서인가를 확인하기 위해 사용한다.
  - 인증서 자체는 공개키의 소유권을 인증하고 해당 키의 특정 예상 용도를 나타낸다.

- 구조

  - 인증서의 소유자 이름
  - 인증서 소유자의 공개 키
  - 인증서의 유효 기간
  - 고유한 UID
  - 인증서의 기타 모든 값을든 해시화한 값

- 체계

  - 인증서 발급 회사에서 시작하는 ROOT 인증서, Intermediate(중간 인증서), Leaf(서버 인증서) 3단계로 구성되어 있고 이를 인증서 체인이라고 한다.
  - 사용자가 구입하는 인증서는 Leaf 인증서이며, 인증서 체인은 하위 구조의 인증서를 서명하고 상위 구조의 인증서를 참고하는 방식으로 만들어진다.
    - ROOT 인증서
      - CA에서 자체 서명한 인증서로 공개키 기반 암호화를 사용한다.
      - 모든 유효한 SSL 인증서는 업계에서 보안 리더로 알려진 신뢰할 수 있는 CA가 발행한 루트 CA인증서 아래에 체인에 위치한다.
    - 중간 인증서
      - 루트 인증서와 SSL 인증서 사이에서 구분을 만들어 위험을 완화하도록 설계된 인증서이다.
      - 루트 인증서가 가장 많은 권한을 갖고 보호되어야 하기 때문에 루트 인증서가 손상될 경우를 대비한다.

<br><br>

# Advanced

### TLS의 인증서에 쓰이는 암호화 알고리즘은 어떤 종류가 있을까요?

- RSA - 비대칭 키
- DSA
- ED25519 - CPU같은 하드웨어 인프라
- EdDSA
- Twisted Edwards curve 등

<br><br>

### HTTP/3은 기존 버전과 어떻게 다를까요? HTTP의 버전 3이 나오게 된 이유는 무엇일까요?

- UDP를 사용하고, 인증과 관련된 Handshake를 한큐에 해결한다.
- TCP의 한계(HOL, Handshake 오버헤드 등)를 극복하기 위해 나왔다.

<br>
